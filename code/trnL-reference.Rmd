---
title: "trnL reference"
output: 
     html_document:
          df_print: paged
          toc: true
          toc_float: true
---

Stepping through this notebook will build a *trnL* reference database, trimmed to sequences amplified by the desired primer set (here, *trnL*g and *trnL*h).

This notebook use 

```{r libraries, include=FALSE, echo=FALSE}
library(Biostrings)
library(here)
library(ShortRead) # for clean()
library(taxonomizr) # for NCBI accession lookup
library(tidyverse)

source(here('code', 'functions', 'find_primer_pair.R'))
source(here('code', 'functions', 'query_ncbi.R'))
```

```{r plotting, include=FALSE, echo=FALSE}
theme_set(theme_bw() +
               theme(
                    axis.text = element_text(size = 12),
                    axis.title = element_text(size = 14,
                                              face = 'bold'),
                    legend.title = element_text(size = 12,
                                                face = 'bold'),
                    strip.text = element_text(size = 12,
                                              face = 'bold')
                     )
)
```

# Read in data 

```{r}
# Primer sequences 
trnLG <- DNAString('GGGCAATCCTGAGCCAA')
trnLH <- DNAString('CCATTGAGTCTCTGCACCTATC')

primers <- list(trnLG, trnLH)
```

```{r}
# Manually curated list of dietary and medicinal plants
plants <- 
     here('data', 'inputs', 'human-foods.csv') |>
     read.csv(stringsAsFactors = FALSE) |>
     filter(category == 'plant') |> 
     pull(scientific_name)

length(plants)
head(plants)
tail(plants)
```

```{r}
# Manual edits
edits <- 
     here('data', 'inputs', 'Manual renaming.csv') |> 
     read_csv() 

edits
```

```{r}
# SQL reference
sql <- '/Volumes/All_Staff/localreference/ncbi_taxonomy/accessionTaxa.sql'
```

```{r}
# Parsed RefSeq data (last organized Jan 2023)
plastid <- 
     readDNAStringSet(
          here('data', 
               'outputs', 
               'parsed-refs',
               'RefSeq',
               'refseq_plastid_species.fasta'))

plastid
```

# Submit query

## RefSeq (local)

### Find primers

```{r}
# Note that there are lots of sequences that include Ns
length(plastid)
length(clean(plastid))
```

```{r}
refseq.trnL <- find_primer_pair(plastid, 
                                fwd = primers[[1]],
                                rev = primers[[2]])

cat(length(refseq.trnL), 'sequences have the primer set')
```

### Subset to foods

Just doing this by a simple grep for now
Could imagine it would be cleaner to process RefSeq to a comparable name as in our query
Keep accessions from raw files, look up taxonomy, then assign a "lowest level" name that would correspond to entries in human-foods.txt.

```{r}
# Find indices of entries matching 
plants.i <- 
     lapply(plants, grep, x = names(refseq.trnL)) %>%
     unlist()

cat('There are', length(plants), 'food plants in our query\n')

# Subset
refseq.trnL <- refseq.trnL[plants.i]
cat(length(refseq.trnL), 'have a trnL sequence in the RefSeq plastid database')
```

```{r}
# Strip name to only NCBI accession
names(refseq.trnL) %>% head()

names(refseq.trnL) <- 
     gsub(names(refseq.trnL),
          pattern = ' .*$',
          replacement = '')

head(names(refseq.trnL))
```
## NCBI (remote)

```{r}
# Pull sequences from NCBI
ncbi.trnL <- query_ncbi(marker = 'trnL',
                        organisms = plants)
```

This is from the total number of available sequences

```{r}
length(ncbi.trnL)
length(clean(ncbi.trnL))
```

### Find primers
Now look for primer binding sites within retrieved sequences.

```{r}
ncbi.trnL <- find_primer_pair(ncbi.trnL, 
                              fwd = primers[[1]],
                              rev = primers[[2]])

cat(length(ncbi.trnL), 'sequences have the primer set')
```

```{r}
# Note some entries are marked as unverified
names(ncbi.trnL)[grepl('UNVERIFIED', names(ncbi.trnL))] |> 
     head(5)

# Remove 
length(ncbi.trnL)
ncbi.trnL <- ncbi.trnL[!(grepl('UNVERIFIED', names(ncbi.trnL)))]
length(ncbi.trnL)
```
Want to convert these long, descriptive names to just an accession and taxon. Strip to accession number, and then use this to do a taxonomic lookup.

```{r}
# Strip name to only NCBI accession
names(ncbi.trnL) |> head()
names(ncbi.trnL) <- 
     names(ncbi.trnL) |> 
     gsub(pattern = ' .+$', replacement = '') |> 
     gsub(pattern = '^>', replacement = '')

head(names(ncbi.trnL))
```

## Combine

### Check overlap

```{r}
length(refseq.trnL)
length(ncbi.trnL)
```

```{r}
# Named as accession numbers:
intersect(names(ncbi.trnL), names(refseq.trnL)) |> length()
setdiff(names(refseq.trnL), names(ncbi.trnL)) |> length()
setdiff(names(ncbi.trnL), names(refseq.trnL)) |> length()
```

Theoretically, RefSeq is entirely contained within NCBI's nucleotide record, but there are entries that are unique to RefSeq here.  Think this is because I restrict the query to "big" NCBI to have the term "trnL" in the record name-- not impossible to overcome, but currently don't have a strategy for handling the # and length of records that get pulled down without that filter in our query term.  This can be an area for future updates.

### Merge
```{r}
# Data frame of results
seqs.df <- 
     data.frame(source = 'RefSeq',
                accession = names(refseq.trnL),
                seq = as.character(refseq.trnL))

seqs.df <- 
     data.frame(source = 'GenBank',
                accession = names(ncbi.trnL),
                seq = as.character(ncbi.trnL)) |> 
     bind_rows(seqs.df)

head(seqs.df)
```

```{r}
# Also add manual additions here
additions <- filter(edits, type == 'add')
additions
```

```{r}
# Note that these don't have primers currently
# To get the most accurate sequence, let's just pull these records from NCBI by their accession number and trim directly
# Note some of these returned sequences are whole genomes-- takes a few mins.
seqs <- 
     entrez_fetch(db='nucleotide', 
                  id = additions$accession, 
                  rettype='fasta') %>%
     # This returns concatenated sequence strings; split apart 
     # so we can re-name inline
     strsplit('\n{2,}') %>% # Usually two newline chars, but sometimes more
     unlist()

# Save this to ultimately combine with taxonomy data, as want to
# be able to identify these sequences after the fact
ex <- '[^>]\\S*' 
accs <- str_extract(seqs, ex) 

# Keep full header for descriptive name
headers <- str_extract(seqs, '^[^\n]*')

seqs <- 
     seqs %>%
     # Now update seqs to sequence only, stripping header
     sub('^[^\n]*\n', '', .) %>%
     # And removing separating \n characters
     gsub('\n', '', .)

# Now add to DNAStringSet
seqs <- DNAStringSet(seqs)
names(seqs) <- accs

seqs <- find_primer_pair(seqs, 
                         fwd = primers[[1]],
                         rev = primers[[2]])
```

```{r}
# This leaves 'source' labeled as NA for these entries
seqs.df <-
     data.frame(seq = as.character(seqs),
                accession = names(seqs)) |> 
     bind_rows(seqs.df) 
```

### Taxonomy

```{r}
# Look up accession taxonomy using taxonomizr-formatted SQL database
ids <- taxonomizr::accessionToTaxa(seqs.df$accession, sql)
```

```{r}
# Any names missing?
any(is.na(ids))
sum(is.na(ids))
```

```{r}
# Which ones?
seqs.df[is.na(ids), c('source', 'accession')]
```

Missing entries are sequence records that have been added to NCBI in the time between making the taxonomic SQL file and now.  

```{r}
# Manually add these by querying in browser with accession
# IMPORTANT: If repeating, check these to make sure they still line up
# If any additions/changes to input files, likely they will not

ids[12] <- 3747 # OP764691.1 Fragaria x ananassa		
ids[2659]	<- 3673 # OP222139.1 Momordica charantia		
ids[2660]	<- 3673 # OP222138.1 Momordica charantia
ids[2983]	<- 59072 # OP096332.1 Muscari neglectum		
ids[2984]	<- 59072 # OP096331.1 Muscari neglectum		
ids[3323]	<- 304130 # NC_070364.1 Physalis philadelphica
ids[3326]	<- 148714 # ON054983.1 Parkia speciosa
ids[3327]	<- 148714 # ON054982.1 Parkia speciosa		
ids[4120]	<- 119830 # ON054979.1 Solanum torvum		
ids[4121]	<- 119830 # ON054978.1 Solanum torvum
ids[4122]	<- 119830 # ON054977.1 Solanum torvum		
ids[4123]	<- 227722 # ON054972.1 Solanum lasiocarpum		
ids[4124]	<- 227722 # ON054971.1 Solanum lasiocarpum
ids[4125]	<- 227722 # ON054970.1 Solanum lasiocarpum	
ids[4126]	<- 227722 # ON054969.1 Solanum lasiocarpum			
ids[4127]	<- 227722 # ON054968.1 Solanum lasiocarpum

# Confirm got them all
any(is.na(ids))
```

```{r}
taxonomy.raw <- taxonomizr::getRawTaxonomy(ids, sql)
```

```{r}
# Pull desired levels from this structure
# Not working within getTaxonomy function
vars <- c("superkingdom", 
          "phylum", 
          "class", 
          "order", 
          "family", 
          "genus",
          "species",
          "subspecies",
          "varietas",
          "forma")

taxonomy <- data.frame(superkingdom = NULL,
                       phylum = NULL,
                       class = NULL,
                       order = NULL,
                       family = NULL,
                       genus = NULL,
                       species = NULL,
                       subspecies = NULL,
                       varietas = NULL,
                       forma = NULL)

for (i in seq_along(taxonomy.raw)){
     row.i <- 
          taxonomy.raw[[i]] |> 
          t() |> 
          data.frame() 
     
     # Pick columns we're interested in
     shared <- intersect(vars, names(row.i))
     row.i <- select(row.i, one_of(shared))
     
     taxonomy <- bind_rows(taxonomy, row.i)
}

# Add taxon ID
taxonomy$taxid <- 
     names(taxonomy.raw) |> 
     trimws() |> 
     as.integer()

taxonomy <- select(taxonomy, taxid, everything())
```

```{r}
head(taxonomy)
```

```{r}
# Join back to accession
nrow(taxonomy) == nrow(seqs.df)

seqs.df <- 
     bind_cols(seqs.df,
               taxonomy)
```

### Manual edits

There are two types of edits we're making:
     - **omissions**: High likelihood an included sequence has an incorrect taxon label, so we exclude it, and
     - **renaming**: The labeled taxon name can be specified more precisely (currently, happens only for *B. oleracea* spp.)

```{r}
edits
```

```{r}
# Handle omissions
omit <- filter(edits, type=='omit')

seqs.df <- 
     filter(seqs.df, 
            !(accession %in% omit$accession & seq %in% omit$sequence))
```

```{r}
# Handle renaming 
name.update <- filter(edits, type=='rename')

filter(seqs.df,
       accession %in% name.update$accession)
```

```{r}
# Note that original sequence 'AC183493.1' not found, leaving off for now
# Will need to generalize this later, but now can just update specifically
seqs.df$varietas[seqs.df$accession == 'AB213010.1'] <- 'Brassica oleracea var. capitata'
seqs.df$varietas[seqs.df$accession == 'AC183493.1'] <- 'Brassica oleracea var. alboglabra'
seqs.df$varietas[seqs.df$accession == 'LR031874.1'] <- 'Brassica oleracea var. italica'
seqs.df$varietas[seqs.df$accession == 'LR031875.1'] <- 'Brassica oleracea var. italica'
seqs.df$varietas[seqs.df$accession == 'LR031876.1'] <- 'Brassica oleracea var. italica'
```

```{r}
# Get lowest-level taxon name
seqs.df <- 
     seqs.df |> 
     MButils::lowest_level() |>
     rename(taxon = 'name') |> 
     select(source, accession, taxon, taxid, superkingdom:forma, seq)
```

#### QC

Check for common errors

```{r}
# Check for degenerate nucleotide characters
grep('[AGCT]*[^AGCT]+', seqs.df$seq)
```

```{r}
# Add a flag to these taxa, to see if there's a back-up sequence
seqs.df$N <- grepl('[AGCT]*[^AGCT]+', seqs.df$seq)

with_n <- 
     seqs.df$taxon[grepl('[AGCT]*[^AGCT]+', seqs.df$seq)] |> 
     unique()
```

```{r}
seqs.df |> 
     filter(taxon %in% with_n) |> 
     group_by(taxon, N) |> 
     count() |> 
     ungroup() |> 
     group_by(taxon) |> 
     summarize(any(!N)) |> 
     arrange(`any(!N)`)
```
Okay, so for all taxa but
- Amaranthus cruentus
- Amaranthus dubius
- Costus erythrophyllus
- Vaccinium tenellum
- Victoria amazonica

we are covered by a second sequence. 

```{r}
# Remove sequences containing Ns
seqs.df <- 
     filter(seqs.df,
            !grepl(pattern = '[AGCT]*[^AGCT]+', seq))
```

####  Get reads in same orientation

```{r}
# Get orientation of sequence by finding primers
# How many mismatches are allowed?
fwd_err <- floor(0.2*length(trnLG))
rev_err <- floor(0.2*length(trnLH))

fwd_err
rev_err
```

```{r}
ref <- DNAStringSet(seqs.df$seq)
names(ref) <- paste(seqs.df$accession, seqs.df$taxon)
```

```{r}
# Forward primer at start of read
fwd_matches <- 
     vmatchPattern(trnLG, 
                   ref, 
                   max.mismatch = fwd_err,
                   fixed = TRUE) |>
     as.data.frame() |> 
     filter(start <= 1) |> 
     mutate(type = 'forward') |> 
     select(group, type)

# Reverse primer at start of read
rev_matches <- 
     vmatchPattern(trnLH, 
                   ref, 
                   max.mismatch = rev_err,
                   fixed = TRUE) |>
     as.data.frame() |> 
     filter(start <= 1) |> 
     mutate(type = 'reverse') |> 
     select(group, type)
```

```{r}
seqs.df <- 
     bind_rows(fwd_matches,
          rev_matches) |> 
     arrange(group) |> 
     bind_cols(seqs.df)

seqs.df |> 
     group_by(type) |> 
     count()
```

```{r}
nrow(rev_matches) + nrow(fwd_matches) == nrow(seqs.df)
```

Now, if a read is reversed, we want to replace it with its reverse complement
```{r}
seqs.df <- 
     mutate(seqs.df,
            seq = ifelse(type == 'reverse',
                         yes = seq |> 
                              DNAStringSet() |> 
                              reverseComplement() |> 
                              as.character(),
                         no = seq)) |> 
     select(-c(type, group))
```

#### Clean results

* Sequences that are the same and that come from the same species can be de-duplicated
* Sequences that are different and come from the same species must be preserved

```{r}
seqs.df |> 
     group_by(taxon, seq)
```
```{r}
dups <- 
     seqs.df |> 
     group_by(taxon) |> 
     summarize(n = sum(duplicated(seq)))

arrange(dups, desc(n))
```

```{r}
sum(dups$n)
```

So the number of sequences we expect after filtering is 
```{r}
dim(seqs.df)[1] - sum(dups$n)
```

```{r}
seqs.df <- 
     seqs.df |>
     group_by(superkingdom,
              phylum,
              class,
              order,
              family,
              genus,
              species,
              subspecies,
              varietas,
              forma, 
              taxon, 
              seq) |> 
     arrange(desc(source), accession) |> # Puts RefSeq accessions first 
     summarize(accession = first(accession)) # Choose the first accession number

dim(seqs.df)
```

## Save

### DADA2

```{r}
# Sort alphabetically (first by species name, and then accession number)
seqs.df <- arrange(seqs.df, 
                   taxon,
                   accession)

# Convert back to DNAStringSet object
trnL <- seqs.df$seq
names(trnL) <- paste(seqs.df$accession, seqs.df$taxon)

trnL <- DNAStringSet(trnL)
trnL
```
```{r}
# Save to file
# writeXStringSet(trnL,
#                 here('data',
#                      'outputs',
#                      'dada2-compatible',
#                      'trnL',
#                      'trnLGH.fasta'))
```

```{r}
seqs.df <- 
     seqs.df |> 
     unite(col = 'name',
           superkingdom:forma,
           sep = ';') 

names(trnL) <- seqs.df$name
```

```{r}
# writeXStringSet(trnL,
#                 here('data',
#                      'outputs',
#                      'dada2-compatible',
#                      'trnL',
#                      'trnLGH_taxonomy.fasta'))
```

### QIIME2 

Taxonomic assignment in QIIME2 with `classify-consensus-vsearch` requires two files:
- `i-reference-reads`, a QIIME artifact containing a FASTA file of sequences identified by their accession
- `i-reference-taxonomy`, a QIIME artifact containing a TSV (tab-separated value) file with two columns: "Feature ID", the same accessions, and "Taxon", the taxonomic lineage with ranks separated by semicolons

```{r}
outdir <- here('data',
               'outputs',
               'qiime2-compatible')

Sys.setenv(QIIME2 = outdir)
```

Note that QIIME2 requires that the FASTA file have unique accessions, so make these unique before proceeding

```{r}
seqs.df <- mutate(seqs.df,
                  acc = make.unique(acc,
                                    sep = '_'))

names(trnL) <- seqs.df$acc
# writeXStringSet(trnL,
#                 file.path(outdir,
#                           'trnL-sequences.fasta'))
```

```{r}
# seqs.df |>
#      select(`Feature ID` = acc,
#             Taxon = name) |>
#      write_delim(delim = '\t',
#                  file.path(outdir,
#                            'trnL-taxonomy.tsv'))
```

```{bash engine.opts='-l'}
# Running this block requires a QIIME2 conda environment on local machine
# Note that yours may differ from the "qiime2-2022.8"; you can find correct name by running conda env list in the terminal
# Convert both of the above objects to QIIME2 artifacts (QZA)
cd "$QIIME2"
conda activate qiime2-2022.8 

qiime tools import \
     --input-path trnL-sequences.fasta \
     --output-path trnL-sequences.qza \
     --type 'FeatureData[Sequence]'
     
qiime tools import \
     --input-path trnL-taxonomy.tsv \
     --output-path trnL-taxonomy.qza \
     --type 'FeatureData[Taxonomy]'
```

